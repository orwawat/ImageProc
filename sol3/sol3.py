from scipy.ndimage.filters import convolve
import numpy as np
import matplotlib.pyplot as plt
from scipy.signal import convolve2d

# TODO - add sertions that size is powers of 2


def get_filter_kernel(filter_size):
    """
        Returns a 1d approximation of a gaussian kernel using binomial coefficients.

        Input:
            kernel_size is an ODD number which is the size of the kernel in each  direction

        Output:
            ker - a 2d matrix array of type np.float32. Its sum is 1 and it contains an approximation of a gaussian kernel
                (with the 0,0 located in the center) in 1d
    """
    if filter_size % 2 == 0:
        raise Exception("Only odd numbers are allowed as kernel sizes")
    ker = np.array([[1]], dtype=np.float32)
    for i in range(filter_size - 1):
        ker = convolve2d(ker, np.array([[1, 1]]))
    return ker / np.sum(ker)


def down_sample(im, filter):
    blurred_im = convolve(im, filter)
    blurred_im = convolve(blurred_im, filter.transpose())
    return blurred_im[::2, ::2]


def up_sample(im, filter):
    expanded_im = np.zeros((im.shape[0] * 2, im.shape[1] * 2))
    expanded_im[::2, ::2] = im
    expanded_im = convolve(expanded_im, 2 * filter.transpose())
    return convolve(expanded_im, 2 * filter)


def build_gaussian_pyramid(im, max_levels, filter_size):
    """
    Construct a Gaussian pyramid of a given image
    :param im: a grayscale image with double values in[0, 1]
    :param max_levels: the maximal number of levels in the resulting pyramid.
    :param filter_size: the size of the Gaussian filter (an odd scalar that represents a squared filter) to be used
                        in constructing the pyramid filter
    :return: pyr, filter_vec
    """
    levels = min(max_levels, int(np.log2(im.shape[0] // 8)), int(np.log2(im.shape[1] // 8)))
    pyr = [0] * levels
    filter_vec = get_filter_kernel(filter_size)
    pyr[0] = im.copy()
    for lv in range(1, levels):
        pyr[lv] = down_sample(pyr[lv - 1], filter_vec)
    return pyr, filter_vec


def build_laplacian_pyramid(im, max_levels, filter_size):
    """
    Construct a Laplacian pyramid of a given image
    :param im: a grayscale image with double values in[0, 1]
    :param max_levels: the maximal number of levels in the resulting pyramid.
    :param filter_size: the size of the Gaussian filter (an odd scalar that represents a squared filter) to be used
                        in constructing the pyramid filter
    :return: pyr, filter_vec
    """
    pyr, filter_vec = build_gaussian_pyramid(im, max_levels, filter_size)
    for lv in range(len(pyr) - 1):
        pyr[lv] -= up_sample(pyr[lv + 1], filter_vec)
    return pyr, filter_vec


def laplacian_to_image(lpyr, filter_vec, coeff):
    """

    :param lpyr: The Laplacian pyramid generated by build_laplacian_pyramid
    :param filter_vec: The filter that are generated by build_laplacian_pyramid
    :param coeff: coeff is a vector. The vector size is the same as the number of levels in the pyramid lpyr. Before
    :return: img
    """
    # TODO Q1: What does it mean to multiply each level in a different value? What do we try to control on?
    img = lpyr[-1] * coeff[-1]
    for i in range(2, len(lpyr) + 1):
        img = up_sample(img, filter_vec) + lpyr[-i] * coeff[-i]
    return img


def linear_stretch(im, new_min, new_max):
    old_min, old_max = im.min(), im.max()
    return ((im - old_min) * (new_max - new_min) / (old_max - old_min)).astype(np.float32)


def render_pyramid(pyr, levels):
    """

    :param pyr: either a Gaussian or Laplacian pyramid as defined above.
    :param levels: the number of levels to present in the result ≤ max_levels.
    :return: res - a single black image in which the pyramid levels of the given pyramid pyr are stacked
                    horizontally (after stretching the values to [0, 1])
    """
    width = np.sum([pyr[i].shape[1] for i in range(levels)])
    height = pyr[0].shape[0]
    res = np.zeros((height, width), dtype=np.float32)
    cur_col = 0
    for i in range(levels):
        end_col = cur_col + pyr[i].shape[1]
        res[:pyr[i].shape[0], cur_col:end_col] = linear_stretch(pyr[i], 0., 1.)
        cur_col = end_col
    return res


def display_pyramid(pyr, levels):
    """

    :param pyr: either a Gaussian or Laplacian pyramid as defined above.
    :param levels: the number of levels to present in the result ≤ max_levels.
    :return:
    """
    res = render_pyramid(pyr, levels)
    plt.imshow(res, cmap=plt.cm.gray)


def pyramid_blending(im1, im2, mask, max_levels, filter_size_im, filter_size_mask):
    """

    :param im1: input grayscale image to be blended.
    :param im2: input grayscale image to be blended. same dimensions as im1
    :param mask: a boolean (i.e. dtype == np.bool) mask containing True and False representing which parts
                    of im1 and im2 should appear in the resulting im_blend. Note that a value of True corresponds to 1,
                    and False corresponds to 0. same dimensions as im1.
    :param max_levels: the max_levels parameter you should use when generating the Gaussian and Laplacian
                        pyramids.
    :param filter_size_im: the size of the Gaussian filter (an odd scalar that represents a squared filter) which
                            defining the filter used in the construction of the Laplacian pyramids of im1 and im2.
    :param filter_size_mask: the size of the Gaussian filter(an odd scalar that represents a squared filter) which
                            defining the filter used in the construction of the Gaussian pyramid of mask.
    :return: im_blend
    """
    pyr1, filter1 = build_laplacian_pyramid(im1, max_levels, filter_size_im)
    pyr2, filter2 = build_laplacian_pyramid(im2, max_levels, filter_size_im)
    pyr_mask, filter_mask = build_gaussian_pyramid(mask.astype(np.float32), max_levels, filter_size_mask)

    new_pyr = []
    for i in range(min(len(pyr1), len(pyr2), len(pyr_mask))):
        new_pyr.append(np.multiply(pyr1[i], pyr_mask[i]) + np.multiply(pyr2[i], (1 - pyr_mask[i])))
    im_blend = laplacian_to_image(new_pyr, filter1, [1] * i)
    return im_blend.clip(0, 1).astype(np.float32)


def blending_example1():
    """

    :return: im1, im2, mask, im_blend
    """
    pass


def blending_example2():
    """

    :return: im1, im2, mask, im_blend
    """
    pass
