from scipy.ndimage.filters import convolve
import numpy as np
import matplotlib.pyplot as plt
from scipy.signal import convolve2d

# TODO - add assertions that size is powers of 2

# --------------------- From sol1 ------------------------
from skimage.color import rgb2gray
from scipy.misc import imread

# Constants
REP_GREY = 1
REP_RGB = 2
MIN_INTENSITY = 0
MAX_INTENSITY = 255
CONV_MODE = 'mirror'

def read_image(filename, representation):
    """
        Reads a given image file and converts it into a given representation
            filename - string containing the image filename to read.
            representation - representation code, either 1 or 2 defining if the output should be either a
                            grayscale image (1) or an RGB image (2).
            return im as np.float32 in range [0,1]
    """
    im = imread(filename)
    if (representation == REP_GREY) & (im.ndim == 2):
        return im.astype(np.float32) / MAX_INTENSITY
    elif (representation == REP_GREY) & (im.ndim == 3):
        return rgb2gray(im).astype(np.float32)
    elif representation == REP_RGB:  # assuming we are not asked to convert grey to rgb
        return im.astype(np.float32) / MAX_INTENSITY
    else:
        raise Exception('Unsupported representation: {0}'.format(representation))


# ------------------------------------------------------------------------------


def get_filter_kernel(filter_size):
    """
        Returns a 1d approximation of a gaussian kernel using binomial coefficients.

        Input:
            kernel_size is an ODD number which is the size of the kernel in each  direction

        Output:
            ker - a 2d matrix array of type np.float32. Its sum is 1 and it contains an approximation of a gaussian kernel
                (with the 0,0 located in the center) in 1d
    """
    if filter_size % 2 == 0:
        raise Exception("Only odd numbers are allowed as kernel sizes")
    ker = np.array([[1]], dtype=np.float32)
    for i in range(filter_size - 1):
        ker = convolve2d(ker, np.array([[1, 1]]))
    return ker / np.sum(ker)


def reduce(im, filter):
    blurred_im = convolve(im, filter, mode=CONV_MODE)
    blurred_im = convolve(blurred_im, filter.transpose(), mode=CONV_MODE)
    return blurred_im[::2, ::2]


def expand(im, filter):
    expanded_im = np.zeros((im.shape[0] * 2, im.shape[1] * 2), dtype=np.float32)
    expanded_im[::2, ::2] = im.copy()
    expanded_im = convolve(expanded_im, 2*filter.transpose(), mode=CONV_MODE)
    return convolve(expanded_im, 2*filter, mode=CONV_MODE)


def build_gaussian_pyramid(im, max_levels, filter_size):
    """
    Construct a Gaussian pyramid of a given image
    :param im: a grayscale image with double values in[0, 1]
    :param max_levels: the maximal number of levels in the resulting pyramid.
    :param filter_size: the size of the Gaussian filter (an odd scalar that represents a squared filter) to be used
                        in constructing the pyramid filter
    :return: pyr, filter_vec
    """
    levels = min(max_levels, int(np.log2(im.shape[0] // 8)), int(np.log2(im.shape[1] // 8)))
    pyr = [0] * levels
    filter_vec = get_filter_kernel(filter_size)
    pyr[0] = im.copy()
    for lv in range(1, levels):
        pyr[lv] = reduce(pyr[lv - 1], filter_vec)
    return pyr, filter_vec


def build_laplacian_pyramid(im, max_levels, filter_size):
    """
    Construct a Laplacian pyramid of a given image
    :param im: a grayscale image with double values in[0, 1]
    :param max_levels: the maximal number of levels in the resulting pyramid.
    :param filter_size: the size of the Gaussian filter (an odd scalar that represents a squared filter) to be used
                        in constructing the pyramid filter
    :return: pyr, filter_vec
    """
    pyr, filter_vec = build_gaussian_pyramid(im, max_levels, filter_size)
    for lv in range(len(pyr) - 1):
        pyr[lv] -= expand(pyr[lv + 1], filter_vec)
    return pyr, filter_vec


def laplacian_to_image(lpyr, filter_vec, coeff):
    """

    :param lpyr: The Laplacian pyramid generated by build_laplacian_pyramid
    :param filter_vec: The filter that are generated by build_laplacian_pyramid
    :param coeff: coeff is a vector. The vector size is the same as the number of levels in the pyramid lpyr. Before
    :return: img
    """
    # TODO Q1: What does it mean to multiply each level in a different value? What do we try to control on?
    weighted_pyr = [lpyr[i] * coeff[i] for i in range(len(lpyr))]
    img = weighted_pyr[-1]
    for i in range(2, len(lpyr) + 1):
        img = expand(img, filter_vec) + weighted_pyr[-i]
    return img


def linear_stretch(im, new_min, new_max):
    old_min, old_max = im.min(), im.max()
    return ((im - old_min) * (new_max - new_min) / (old_max - old_min)).astype(np.float32)


def render_pyramid(pyr, levels):
    """

    :param pyr: either a Gaussian or Laplacian pyramid as defined above.
    :param levels: the number of levels to present in the result ≤ max_levels.
    :return: res - a single black image in which the pyramid levels of the given pyramid pyr are stacked
                    horizontally (after stretching the values to [0, 1])
    """
    width = np.sum([pyr[i].shape[1] for i in range(levels)])
    height = pyr[0].shape[0]
    res = np.zeros((height, width), dtype=np.float32)
    cur_col = 0
    for i in range(levels):
        end_col = cur_col + pyr[i].shape[1]
        res[:pyr[i].shape[0], cur_col:end_col] = linear_stretch(pyr[i], 0., 1.)
        cur_col = end_col
    return res


def display_pyramid(pyr, levels):
    """

    :param pyr: either a Gaussian or Laplacian pyramid as defined above.
    :param levels: the number of levels to present in the result ≤ max_levels.
    :return:
    """
    res = render_pyramid(pyr, levels)
    plt.imshow(res, cmap=plt.cm.gray)


def pyramid_blending(im1, im2, mask, max_levels, filter_size_im, filter_size_mask):
    """

    :param im1: input grayscale image to be blended.
    :param im2: input grayscale image to be blended. same dimensions as im1
    :param mask: a boolean (i.e. dtype == np.bool) mask containing True and False representing which parts
                    of im1 and im2 should appear in the resulting im_blend. Note that a value of True corresponds to 1,
                    and False corresponds to 0. same dimensions as im1.
    :param max_levels: the max_levels parameter you should use when generating the Gaussian and Laplacian
                        pyramids.
    :param filter_size_im: the size of the Gaussian filter (an odd scalar that represents a squared filter) which
                            defining the filter used in the construction of the Laplacian pyramids of im1 and im2.
    :param filter_size_mask: the size of the Gaussian filter(an odd scalar that represents a squared filter) which
                            defining the filter used in the construction of the Gaussian pyramid of mask.
    :return: im_blend
    """
    pyr1, filter1 = build_laplacian_pyramid(im1, max_levels, filter_size_im)
    pyr2, filter2 = build_laplacian_pyramid(im2, max_levels, filter_size_im)
    pyr_mask, filter_mask = build_gaussian_pyramid(mask.astype(np.float32), max_levels, filter_size_mask)

    new_pyr = []
    for i in range(min(len(pyr1), len(pyr2), len(pyr_mask))):
        new_pyr.append(np.multiply(pyr1[i], pyr_mask[i]) + np.multiply(pyr2[i], (1 - pyr_mask[i])))
    im_blend = laplacian_to_image(new_pyr, filter1, [1] * (i+1))
    return im_blend.clip(0, 1).astype(np.float32)


def blend_rgb_image(im1, im2, mask, max_levels, filter_size_im, filter_size_mask):
    im_blend = np.zeros(im1.shape)
    for dim in range(im1.ndim):
        im_blend[:,:,dim] = pyramid_blending(im1[:,:,dim], im2[:,:,dim], mask, max_levels, filter_size_im, filter_size_mask)
    return im_blend

def blending_example1():
    """

    :return: im1, im2, mask, im_blend
    """
    # TODO - see if we are allowed
    from scipy.misc import imresize
    im1 = read_image(r"C:\Users\Maor\Documents\ImageProc\sol3\dome.jpg", 2)
    valid_height = 2 ** int(np.log2(im1.shape[0]))
    valid_width = 2 ** int(np.log2(im1.shape[1]))
    im1 = imresize(im1, (valid_height, valid_width, im1.ndim)).astype(np.float32) / 255.0
    im2 = read_image(r"C:\Users\Maor\Documents\ImageProc\sol3\fish4.jpg", 2)
    im2 = imresize(im2, im1.shape).astype(np.float32) / 255.0
    mask = 1-read_image(r"C:\Users\Maor\Documents\ImageProc\sol3\mask5.jpg", 1)
    mask[mask<=0.5] = 0
    mask[mask>0.5] = 1
    mask = imresize(mask, im1.shape).astype(np.bool)
    im_blend = blend_rgb_image(im1, im2, mask, 8, 5, 5)
    plt.imshow(im_blend)


def blending_example2():
    """

    :return: im1, im2, mask, im_blend
    """
    pass
