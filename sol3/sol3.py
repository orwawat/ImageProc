from scipy.ndimage.filters import convolve
import numpy as np
import matplotlib.pyplot as plt

def get_filter_kernel(filter_size):
    """
        Returns a 1d approximation of a gaussian kernel using binomial coefficients.

        Input:
            kernel_size is an ODD number which is the size of the kernel in each  direction

        Output:
            ker - a 2d matrix array of type np.float32. Its sum is 1 and it contains an approximation of a gaussian kernel
                (with the 0,0 located in the center) in 1d
    """
    if filter_size % 2 == 0:
        raise Exception("Only odd numbers are allowed as kernel sizes")
    ker = np.array([[1]], dtype=np.float32)
    for i in range(filter_size - 1):
        ker = convolve(ker, np.array([[1, 1]]))
    return ker / np.sum(ker)

def down_sample(im, filter):
    blurred_im = convolve(im, filter)
    blurred_im = convolve(blurred_im, filter.transpose())
    return blurred_im[::2, ::2]

def up_sample(im, filter):
    expanded_im = np.zeros((im.shape[0]*2,im.shape[1]*2))
    expanded_im[::2, ::2] = im
    expanded_im = convolve(expanded_im, 2*filter.transpose())
    return convolve(expanded_im, 2*filter)

def build_gaussian_pyramid(im, max_levels, filter_size):
    """
    Construct a Gaussian pyramid of a given image
    :param im: a grayscale image with double values in[0, 1]
    :param max_levels: the maximal number of levels in the resulting pyramid.
    :param filter_size: the size of the Gaussian filter (an odd scalar that represents a squared filter) to be used
                        in constructing the pyramid filter
    :return: pyr, filter_vec
    """
    levels = min(max_levels, int(np.log2(im.shape[0]//16)), int(np.log2(im.shape[1]//16)))
    pyr = [0] * levels
    filter_vec = get_filter_kernel(filter_size)
    pyr[0] = im
    for lv in range(1, levels):
        pyr[lv] = down_sample(pyr[lv-1], filter_vec)
    return pyr, filter_vec

def build_laplacian_pyramid(im, max_levels, filter_size):
    """
    Construct a Laplacian pyramid of a given image
    :param im: a grayscale image with double values in[0, 1]
    :param max_levels: the maximal number of levels in the resulting pyramid.
    :param filter_size: the size of the Gaussian filter (an odd scalar that represents a squared filter) to be used
                        in constructing the pyramid filter
    :return: pyr, filter_vec
    """
    pyr, filter_vec = build_gaussian_pyramid(im, max_levels, filter_size)
    for lv in range(len(pyr)-1):
        pyr[lv] = up_sample(pyr[lv + 1], filter_vec)
    return pyr, filter_vec

def laplacian_to_image(lpyr, filter_vec, coeff):
    """

    :param lpyr: The Laplacian pyramid generated by build_laplacian_pyramid
    :param filter_vec: The filter that are generated by build_laplacian_pyramid
    :param coeff: coeff is a vector. The vector size is the same as the number of levels in the pyramid lpyr. Before
    :return: img
    """
    # TODO Q1: What does it mean to multiply each level in a different value? What do we try to control on?
    img = lpyr[-1] * coeff[-1]
    for i in range(2, len(lpyr)+1):
        img = up_sample(img, filter_vec) + lpyr[-i] * coeff[-i]
    return img

def linear_stretch(im, new_min, new_max):
    old_min, old_max = im.min(), im.max()
    return ((im - old_min) * (new_max - new_min) / (old_max - old_min) ).astype(np.float32)


def render_pyramid(pyr, levels):
    """

    :param pyr: either a Gaussian or Laplacian pyramid as defined above.
    :param levels: the number of levels to present in the result ≤ max_levels.
    :return: res - a single black image in which the pyramid levels of the given pyramid pyr are stacked
                    horizontally (after stretching the values to [0, 1])
    """
    width = np.sum([pyr[i].shape[1] for i in range(levels)])
    height = pyr[0].shape[0]
    res = np.zeros((height, width), dtype=np.float32)
    cur_col = 0
    for i in range(levels):
        end_col = cur_col + pyr[i].shape[1]
        res[:pyr[i].shape[0], cur_col:end_col] = linear_stretch(pyr[i], 0., 1.)
        cur_col = end_col
    return res

def display_pyramid(pyr, levels):
    """

    :param pyr: either a Gaussian or Laplacian pyramid as defined above.
    :param levels: the number of levels to present in the result ≤ max_levels.
    :return:
    """
    res = render_pyramid(pyr, levels)
    plt.imshow(res)
